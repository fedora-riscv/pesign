From db4e0e71d71d794b4d95bfc90145ea243f7d064b Mon Sep 17 00:00:00 2001
From: Peter Jones <pjones@redhat.com>
Date: Tue, 28 Apr 2020 10:21:52 -0400
Subject: [PATCH 25/42] Rework the wildly undocumented NSS password file goo.

This probably doesn't work yet.
---
 src/cms_common.c    | 223 ++++++++++------
 src/cms_pe_common.c |   2 +-
 src/daemon.c        |   8 +-
 src/password.c      | 614 +++++++++++++++++++++++++++++---------------
 src/pesign.c        |  45 +++-
 src/signer_info.c   |   9 +-
 src/cms_common.h    |  57 +++-
 7 files changed, 646 insertions(+), 312 deletions(-)

diff --git a/src/cms_common.c b/src/cms_common.c
index 75a95f053a2..c2f34e515a2 100644
--- a/src/cms_common.c
+++ b/src/cms_common.c
@@ -164,11 +164,31 @@ cms_context_fini(cms_context *cms)
 		cms->cert = NULL;
 	}
 
+	switch (cms->pwdata.source) {
+	case PW_SOURCE_INVALID:
+	case PW_PROMPT:
+	case PW_DEVICE:
+	case PW_FROMFILEDB:
+	case PW_FROMENV:
+	case PW_SOURCE_MAX:
+		break;
+	case PW_DATABASE:
+		xfree(cms->pwdata.data);
+		break;
+	case PW_PLAINTEXT:
+		memset(cms->pwdata.data, 0, strlen(cms->pwdata.data));
+		xfree(cms->pwdata.data);
+		break;
+	}
+	cms->pwdata.source = PW_SOURCE_INVALID;
+	cms->pwdata.orig_source = PW_SOURCE_INVALID;
+
 	if (cms->privkey) {
 		free(cms->privkey);
 		cms->privkey = NULL;
 	}
 
+
 	/* These were freed when the arena was destroyed */
 	if (cms->tokenname)
 		cms->tokenname = NULL;
@@ -255,9 +275,35 @@ void cms_set_pw_callback(cms_context *cms, PK11PasswordFunc func)
 	cms->func = func;
 }
 
-void cms_set_pw_data(cms_context *cms, void *pwdata)
+void cms_set_pw_data(cms_context *cms, secuPWData *pwdata)
 {
-	cms->pwdata = pwdata;
+	ingress();
+
+	switch (cms->pwdata.source) {
+	case PW_SOURCE_INVALID:
+	case PW_PROMPT:
+	case PW_DEVICE:
+	case PW_SOURCE_MAX:
+		break;
+
+	case PW_FROMENV:
+	case PW_FROMFILEDB:
+	case PW_PLAINTEXT:
+		memset(cms->pwdata.data, 0, strlen(cms->pwdata.data));
+		xfree(cms->pwdata.data);
+		break;
+
+	case PW_DATABASE:
+		xfree(cms->pwdata.data);
+		break;
+	}
+	memmove(&cms->pwdata, pwdata, sizeof(*pwdata));
+
+	dprintf("pwdata:%p", pwdata);
+	dprintf("pwdata->source:%d", pwdata->source);
+	dprintf("pwdata->data:%p (\"%s\")", pwdata->data,
+		pwdata->data ? pwdata->data : "(null)");
+	egress();
 }
 
 int
@@ -280,24 +326,26 @@ set_digest_parameters(cms_context *cms, char *name)
 	return -1;
 }
 
-struct cbdata {
-	CERTCertificate *cert;
+struct validity_cbdata {
+	cms_context *cms;
 	PK11SlotListElement *psle;
-	secuPWData *pwdata;
+	PK11SlotInfo *slot;
+	CERTCertificate *cert;
 };
 
 static SECStatus
 is_valid_cert(CERTCertificate *cert, void *data)
 {
-	struct cbdata *cbdata = (struct cbdata *)data;
-
-	PK11SlotInfo *slot = cbdata->psle->slot;
-	void *pwdata = cbdata->pwdata;
-
+	struct validity_cbdata *cbd = (struct validity_cbdata *)data;
+	PK11SlotInfo *slot = cbd->slot;
 	SECKEYPrivateKey *privkey = NULL;
-	privkey = PK11_FindPrivateKeyFromCert(slot, cert, pwdata);
+
+	if (cert == NULL)
+		return SECFailure;
+
+	privkey = PK11_FindPrivateKeyFromCert(slot, cert, cbd->cms);
 	if (privkey != NULL) {
-		cbdata->cert = cert;
+		cbd->cert = CERT_DupCertificate(cert);
 		SECKEY_DestroyPrivateKey(privkey);
 		return SECSuccess;
 	}
@@ -307,9 +355,15 @@ is_valid_cert(CERTCertificate *cert, void *data)
 static SECStatus
 is_valid_cert_without_private_key(CERTCertificate *cert, void *data)
 {
-	struct cbdata *cbdata = (struct cbdata *)data;
-	if (cert) {
-		cbdata->cert = cert;
+	struct validity_cbdata *cbd = (struct validity_cbdata *)data;
+	PK11SlotInfo *slot = cbd->slot;
+	SECKEYPrivateKey *privkey = NULL;
+
+	if (cert == NULL)
+		return SECFailure;
+	privkey = PK11_FindPrivateKeyFromCert(slot, cert, cbd->cms);
+	if (privkey == NULL) {
+		cbd->cert = CERT_DupCertificate(cert);
 		return SECSuccess;
 	}
 	return SECFailure;
@@ -338,12 +392,10 @@ PK11_DestroySlotListElement(PK11SlotList *slots, PK11SlotListElement **psle)
 int
 unlock_nss_token(cms_context *cms)
 {
-	secuPWData pwdata_val = { 0, 0 };
-	void *pwdata = cms->pwdata ? cms->pwdata : &pwdata_val;
 	PK11_SetPasswordFunc(cms->func ? cms->func : SECU_GetModulePassword);
 
 	PK11SlotList *slots = NULL;
-	slots = PK11_GetAllTokens(CKM_RSA_PKCS, PR_FALSE, PR_TRUE, pwdata);
+	slots = PK11_GetAllTokens(CKM_RSA_PKCS, PR_FALSE, PR_TRUE, cms);
 	if (!slots)
 		cmsreterr(-1, cms, "could not get pk11 token list");
 
@@ -367,20 +419,21 @@ unlock_nss_token(cms_context *cms)
 		save_port_err() {
 			PK11_FreeSlotList(slots);
 		}
-		cms->log(cms, LOG_ERR, "could not find token \"%s\"",
-			cms->tokenname);
-		return -1;
+		nssreterr(-1, "Could not find token \"%s\"", cms->tokenname);
 	}
 
 	SECStatus status;
 	if (PK11_NeedLogin(psle->slot) &&
-			!PK11_IsLoggedIn(psle->slot, pwdata)) {
-		status = PK11_Authenticate(psle->slot, PR_TRUE, pwdata);
+			!PK11_IsLoggedIn(psle->slot, cms)) {
+		status = PK11_Authenticate(psle->slot, PR_TRUE, cms);
 		if (status != SECSuccess) {
-			PK11_DestroySlotListElement(slots, &psle);
-			PK11_FreeSlotList(slots);
-			cms->log(cms, LOG_ERR, "authentication failed for "
-				"token \"%s\"", cms->tokenname);
+			save_port_err() {
+				PK11_DestroySlotListElement(slots, &psle);
+				PK11_FreeSlotList(slots);
+				cms->log(cms, LOG_ERR,
+					 "authentication failed for token \"%s\"",
+					 cms->tokenname);
+			}
 			return -1;
 		}
 	}
@@ -393,17 +446,16 @@ unlock_nss_token(cms_context *cms)
 int
 find_certificate(cms_context *cms, int needs_private_key)
 {
+	struct validity_cbdata cbd;
 	if (!cms->certname || !*cms->certname) {
 		cms->log(cms, LOG_ERR, "no certificate name specified");
 		return -1;
 	}
 
-	secuPWData pwdata_val = { 0, 0 };
-	void *pwdata = cms->pwdata ? cms->pwdata : &pwdata_val;
 	PK11_SetPasswordFunc(cms->func ? cms->func : SECU_GetModulePassword);
 
 	PK11SlotList *slots = NULL;
-	slots = PK11_GetAllTokens(CKM_RSA_PKCS, PR_FALSE, PR_TRUE, pwdata);
+	slots = PK11_GetAllTokens(CKM_RSA_PKCS, PR_FALSE, PR_TRUE, cms);
 	if (!slots)
 		cmsreterr(-1, cms, "could not get pk11 token list");
 
@@ -427,19 +479,20 @@ find_certificate(cms_context *cms, int needs_private_key)
 		save_port_err() {
 			PK11_FreeSlotList(slots);
 		}
-		cms->log(cms, LOG_ERR, "could not find token \"%s\"",
-			cms->tokenname);
-		return -1;
+		nssreterr(-1, "Could not find token \"%s\"", cms->tokenname);
 	}
 
 	SECStatus status;
-	if (PK11_NeedLogin(psle->slot) && !PK11_IsLoggedIn(psle->slot, pwdata)) {
-		status = PK11_Authenticate(psle->slot, PR_TRUE, pwdata);
+	if (PK11_NeedLogin(psle->slot) && !PK11_IsLoggedIn(psle->slot, cms)) {
+		status = PK11_Authenticate(psle->slot, PR_TRUE, cms);
 		if (status != SECSuccess) {
-			PK11_DestroySlotListElement(slots, &psle);
-			PK11_FreeSlotList(slots);
-			cms->log(cms, LOG_ERR, "authentication failed for "
-				"token \"%s\"", cms->tokenname);
+			save_port_err() {
+				PK11_DestroySlotListElement(slots, &psle);
+				PK11_FreeSlotList(slots);
+				cms->log(cms, LOG_ERR,
+					 "authentication failed for token \"%s\"",
+					 cms->tokenname);
+			}
 			return -1;
 		}
 	}
@@ -459,35 +512,37 @@ find_certificate(cms_context *cms, int needs_private_key)
 		.len = strlen(cms->certname) + 1,
 		.type = siUTF8String,
 	};
-	struct cbdata cbdata = {
-		.cert = NULL,
-		.psle = psle,
-		.pwdata = pwdata,
-	};
+
+	cms->psle = psle;
+
+	cbd.cms = cms;
+	cbd.psle = psle;
+	cbd.slot = psle->slot;
+	cbd.cert = NULL;
 
 	if (needs_private_key) {
 		status = PK11_TraverseCertsForNicknameInSlot(&nickname,
-					psle->slot, is_valid_cert, &cbdata);
+					psle->slot, is_valid_cert, &cbd);
 	} else {
 		status = PK11_TraverseCertsForNicknameInSlot(&nickname,
 					psle->slot,
 					is_valid_cert_without_private_key,
-					&cbdata);
+					&cbd);
 	}
-	if (status != SECSuccess || cbdata.cert == NULL) {
-		save_port_err() {
-			CERT_DestroyCertList(certlist);
-			PK11_DestroySlotListElement(slots, &psle);
-			PK11_FreeSlotList(slots);
-		}
+	if (status == SECSuccess && cbd.cert != NULL) {
+		if (cms->cert)
+			CERT_DestroyCertificate(cms->cert);
+		cms->cert = CERT_DupCertificate(cbd.cert);
+	}
+
+	save_port_err() {
+		CERT_DestroyCertList(certlist);
+		PK11_DestroySlotListElement(slots, &psle);
+		PK11_FreeSlotList(slots);
+		cms->psle = NULL;
+	}
+	if (status != SECSuccess || cms->cert == NULL)
 		cmsreterr(-1, cms, "could not find certificate in list");
-	}
-
-	cms->cert = CERT_DupCertificate(cbdata.cert);
-
-	PK11_DestroySlotListElement(slots, &psle);
-	PK11_FreeSlotList(slots);
-	CERT_DestroyCertList(certlist);
 
 	return 0;
 }
@@ -500,12 +555,10 @@ find_slot_for_token(cms_context *cms, PK11SlotInfo **slot)
 		return -1;
 	}
 
-	secuPWData pwdata_val = { 0, 0 };
-	void *pwdata = cms->pwdata ? cms->pwdata : &pwdata_val;
 	PK11_SetPasswordFunc(cms->func ? cms->func : SECU_GetModulePassword);
 
 	PK11SlotList *slots = NULL;
-	slots = PK11_GetAllTokens(CKM_RSA_PKCS, PR_FALSE, PR_TRUE, pwdata);
+	slots = PK11_GetAllTokens(CKM_RSA_PKCS, PR_FALSE, PR_TRUE, cms);
 	if (!slots)
 		cmsreterr(-1, cms, "could not get pk11 token list");
 
@@ -529,19 +582,20 @@ find_slot_for_token(cms_context *cms, PK11SlotInfo **slot)
 		save_port_err() {
 			PK11_FreeSlotList(slots);
 		}
-		cms->log(cms, LOG_ERR, "could not find token \"%s\"",
-			cms->tokenname);
-		return -1;
+		nssreterr(-1, "Could not find token \"%s\"", cms->tokenname);
 	}
 
 	SECStatus status;
-	if (PK11_NeedLogin(psle->slot) && !PK11_IsLoggedIn(psle->slot, pwdata)) {
-		status = PK11_Authenticate(psle->slot, PR_TRUE, pwdata);
+	if (PK11_NeedLogin(psle->slot) && !PK11_IsLoggedIn(psle->slot, cms)) {
+		status = PK11_Authenticate(psle->slot, PR_TRUE, cms);
 		if (status != SECSuccess) {
-			PK11_DestroySlotListElement(slots, &psle);
-			PK11_FreeSlotList(slots);
-			cms->log(cms, LOG_ERR, "authentication failed for "
-				"token \"%s\"", cms->tokenname);
+			save_port_err() {
+				PK11_DestroySlotListElement(slots, &psle);
+				PK11_FreeSlotList(slots);
+				cms->log(cms, LOG_ERR,
+					 "authentication failed for token \"%s\"",
+					 cms->tokenname);
+			}
 			return -1;
 		}
 	}
@@ -557,12 +611,10 @@ find_named_certificate(cms_context *cms, char *name, CERTCertificate **cert)
 		return -1;
 	}
 
-	secuPWData pwdata_val = { 0, 0 };
-	void *pwdata = cms->pwdata ? cms->pwdata : &pwdata_val;
 	PK11_SetPasswordFunc(cms->func ? cms->func : SECU_GetModulePassword);
 
 	PK11SlotList *slots = NULL;
-	slots = PK11_GetAllTokens(CKM_RSA_PKCS, PR_FALSE, PR_TRUE, pwdata);
+	slots = PK11_GetAllTokens(CKM_RSA_PKCS, PR_FALSE, PR_TRUE, cms);
 	if (!slots)
 		cmsreterr(-1, cms, "could not get pk11 token list");
 
@@ -585,20 +637,23 @@ find_named_certificate(cms_context *cms, char *name, CERTCertificate **cert)
 	if (!psle) {
 		save_port_err() {
 			PK11_FreeSlotList(slots);
+			cms->log(cms, LOG_ERR, "could not find token \"%s\"",
+				 cms->tokenname);
 		}
-		cms->log(cms, LOG_ERR, "could not find token \"%s\"",
-			cms->tokenname);
 		return -1;
 	}
 
 	SECStatus status;
-	if (PK11_NeedLogin(psle->slot) && !PK11_IsLoggedIn(psle->slot, pwdata)) {
-		status = PK11_Authenticate(psle->slot, PR_TRUE, pwdata);
+	if (PK11_NeedLogin(psle->slot) && !PK11_IsLoggedIn(psle->slot, cms)) {
+		status = PK11_Authenticate(psle->slot, PR_TRUE, cms);
 		if (status != SECSuccess) {
-			PK11_DestroySlotListElement(slots, &psle);
-			PK11_FreeSlotList(slots);
-			cms->log(cms, LOG_ERR, "authentication failed for "
-				"token \"%s\"", cms->tokenname);
+			save_port_err() {
+				PK11_DestroySlotListElement(slots, &psle);
+				PK11_FreeSlotList(slots);
+				cms->log(cms, LOG_ERR,
+					 "authentication failed for token \"%s\"",
+					 cms->tokenname);
+			}
 			return -1;
 		}
 	}
@@ -1492,14 +1547,14 @@ generate_keys(cms_context *cms, PK11SlotInfo *slot,
 	};
 
 	SECStatus rv;
-	rv = PK11_Authenticate(slot, PR_TRUE, cms->pwdata);
+	rv = PK11_Authenticate(slot, PR_TRUE, cms);
 	if (rv != SECSuccess)
 		cmsreterr(-1, cms, "could not authenticate with pk11 service");
 
 	void *params = &rsaparams;
 	*privkey = PK11_GenerateKeyPair(slot, CKM_RSA_PKCS_KEY_PAIR_GEN,
 					params, pubkey, PR_TRUE, PR_TRUE,
-					cms->pwdata);
+					cms);
 	if (!*privkey)
 		cmsreterr(-1, cms, "could not generate RSA keypair");
 	return 0;
diff --git a/src/cms_pe_common.c b/src/cms_pe_common.c
index 00061804a78..bd96fe91d69 100644
--- a/src/cms_pe_common.c
+++ b/src/cms_pe_common.c
@@ -275,7 +275,7 @@ generate_digest(cms_context *cms, Pe *pe, int padded)
 			char *name = shdrs[i].name;
 			if (name && name[0] == '/')
 				name = get_str(pe, name + 1);
-			dprintf("section:\"%s\"\n", name);
+			dprintf("section:\"%s\"\n", name ? name : "(null)");
 			if (name && !strcmp(name, ".vendor_cert")) {
 				dprintf("skipping .vendor_cert section\n");
 				hashed_bytes += hash_size;
diff --git a/src/daemon.c b/src/daemon.c
index 8522250c2b4..9a804b37e64 100644
--- a/src/daemon.c
+++ b/src/daemon.c
@@ -237,8 +237,14 @@ malformed:
 	if (!pin)
 		goto oom;
 
+	secuPWData pwdata;
+
+	memset(&pwdata, 0, sizeof(pwdata));
+	pwdata.source = pwdata.orig_source = PW_PLAINTEXT;
+	pwdata.data = pin;
+
 	cms_set_pw_callback(ctx->cms, get_password_passthrough);
-	cms_set_pw_data(ctx->cms, pin);
+	cms_set_pw_data(ctx->cms, &pwdata);
 
 	rc = unlock_nss_token(ctx->cms);
 
diff --git a/src/password.c b/src/password.c
index 0da880a659d..0a4ef411ff7 100644
--- a/src/password.c
+++ b/src/password.c
@@ -19,14 +19,17 @@
 
 #include "fix_coverity.h"
 
+#include <err.h>
 #include <limits.h>
 #include <stdlib.h>
+#include <string.h>
 #include <termios.h>
 #include <unistd.h>
 
 #include "pesign.h"
 
 #include <seccomon.h>
+#include <secerr.h>
 #include <secitem.h>
 #include <secport.h>
 #include <pk11pub.h>
@@ -35,207 +38,324 @@
 #include <prerror.h>
 #include <prprf.h>
 
-static void echoOff(int fd)
+#include "list.h"
+
+static const char * const pw_source_names[] = {
+	[PW_SOURCE_INVALID] = "PW_SOURCE_INVALID",
+	[PW_PROMPT] = "PW_PROMPT",
+	[PW_DEVICE] = "PW_DEVICE",
+	[PW_PLAINTEXT] = "PW_PLAINTEXT",
+	[PW_FROMFILEDB] = "PW_FROMFILEDB",
+	[PW_DATABASE] = "PW_DATABASE",
+	[PW_FROMENV] = "PW_FROMENV",
+
+	[PW_SOURCE_MAX] = "PW_SOURCE_MAX"
+};
+
+static void
+print_prompt(FILE *in, FILE *out, char *prompt)
 {
-    if (isatty(fd)) {
+	int infd = fileno(in);
 	struct termios tio;
-	tcgetattr(fd, &tio);
+
+	if (!isatty(infd))
+		return;
+
+	fprintf(out, "%s", prompt);
+	fflush(out);
+
+	tcgetattr(infd, &tio);
 	tio.c_lflag &= ~ECHO;
-	tcsetattr(fd, TCSAFLUSH, &tio);
-    }
+	tcsetattr(infd, TCSAFLUSH, &tio);
 }
 
-static void echoOn(int fd)
+static inline char *
+get_env(const char *name)
 {
-    if (isatty(fd)) {
+	char *value;
+
+	value = secure_getenv(name);
+	if (value)
+		value = strdup(value);
+	return value;
+}
+
+static int
+read_password(FILE *in, FILE *out, char *buf, size_t bufsz)
+{
+	int infd = fileno(in);
 	struct termios tio;
-	tcgetattr(fd, &tio);
-	tio.c_lflag |= ECHO;
-	tcsetattr(fd, TCSAFLUSH, &tio);
-    }
+	char *ret;
+
+	ret = fgets(buf, bufsz, in);
+
+	if (isatty(infd)) {
+		fprintf(out, "\n");
+		fflush(out);
+
+		tcgetattr(infd, &tio);
+		tio.c_lflag |= ECHO;
+		tcsetattr(infd, TCSAFLUSH, &tio);
+	}
+	if (ret == NULL)
+		return -1;
+
+	buf[strlen(buf)-1] = '\0';
+	return 0;
 }
 
-static PRBool SEC_BlindCheckPassword(char *cp)
+static PRBool
+check_password(char *cp)
 {
-    if (cp != NULL) {
+	unsigned int i;
+
+	if (cp == NULL)
+		return PR_FALSE;
+
+	for (i = 0; cp[i] != 0; i++) {
+		if (!isprint(cp[i]))
+			return PR_FALSE;
+	}
+	if (i == 0)
+		return PR_FALSE;
 	return PR_TRUE;
-    }
-    return PR_FALSE;
 }
 
-static char *SEC_GetPassword(FILE *input, FILE *output, char *prompt,
-			       PRBool (*ok)(char *))
+static char *
+get_password(FILE *input, FILE *output, char *prompt, PRBool (*ok)(char *))
 {
-    int infd  = fileno(input);
-    int isTTY = isatty(infd);
-    char phrase[200] = {'\0'};      /* ensure EOF doesn't return junk */
-
-    for (;;) {
-	/* Prompt for password */
-	if (isTTY) {
-	    echoOff(infd);
-	    fprintf(output, "%s", prompt);
-            fflush (output);
-	}
+	int infd = fileno(input);
+	char phrase[200];
+	size_t size = sizeof(phrase);
 
-	fgets ( phrase, sizeof(phrase), input);
+	ingress();
+	memset(phrase, 0, size);
 
-	if (isTTY) {
-	    fprintf(output, "\n");
-	    echoOn(infd);
-	}
+	while(true) {
+		int rc;
 
-	/* stomp on newline */
-	phrase[PORT_Strlen(phrase)-1] = 0;
+		print_prompt(input, output, prompt);
+		rc = read_password(input, output, phrase, size);
+		if (rc < 0)
+			return NULL;
 
-	/* Validate password */
-	if (!(*ok)(phrase)) {
-	    /* Not weird enough */
-	    if (!isTTY) return 0;
-	    fprintf(output, "Password must be at least 8 characters long with one or more\n");
-	    fprintf(output, "non-alphabetic characters\n");
-	    continue;
+		if (!ok)
+			break;
+
+		if ((*ok)(phrase))
+			break;
+
+		if (!isatty(infd))
+			return NULL;
+		fprintf(output, "Password does not meet requirements.\n");
+		fflush(output);
 	}
-	return (char*) PORT_Strdup(phrase);
-    }
-}
 
-static char consoleName[] = { "/dev/tty" };
+	egress();
+	return (char *)PORT_Strdup(phrase);
+}
 
 static char *
-SECU_GetPasswordString(void *arg UNUSED,
-		       char *prompt UNUSED)
+SECU_GetPasswordString(void *arg UNUSED, char *prompt)
+{
+	char *ret;
+	ingress();
+	ret = get_password(stdin, stdout, prompt, check_password);
+	egress();
+	return ret;
+}
+
+static int token_pass_cmp(const void *tp0p, const void *tp1p)
+{
+	const struct token_pass * const tp0 = (const struct token_pass * const)tp0p;
+	const struct token_pass * const tp1 = (const struct token_pass * const)tp1p;
+	int rc;
+
+	if (!tp1->token || !tp0->token)
+		return tp1->token - tp0->token;
+	rc = strcmp(tp0->token, tp1->token);
+	if (rc == 0)
+		rc = strcmp(tp0->pass, tp1->pass);
+	return rc;
+}
+
+static int
+parse_pwfile_line(char *start, struct token_pass *tp)
 {
-    char *p = NULL;
-    FILE *input, *output;
-
-    /* open terminal */
-    input = fopen(consoleName, "r");
-    if (input == NULL) {
-	fprintf(stderr, "Error opening input terminal %s for read\n",
-		consoleName);
-	return NULL;
-    }
-
-    output = fopen(consoleName, "w");
-    if (output == NULL) {
-	fclose(input);
-	fprintf(stderr, "Error opening output terminal %s for write\n",
-		consoleName);
-	return NULL;
-    }
-
-    p = SEC_GetPassword (input, output, prompt, SEC_BlindCheckPassword);
-
-    fclose(input);
-    fclose(output);
-
-    return p;
+	size_t span, escspan;
+	char *line = start;
+	size_t offset = 0;
+
+	span = strspn(line, whitespace_and_eol_chars);
+	dprintf("whitespace span is %zd", span);
+	if (span == 0 && line[span] == '\0')
+		return -1;
+	line += span;
+
+	tp->token = NULL;
+	tp->pass = line;
+
+	offset = 0;
+	do {
+		span = strcspn(line + offset, whitespace_and_eol_chars);
+		escspan = strescspn(line + offset);
+		if (escspan < span)
+			offset += escspan + 2;
+	} while(escspan < span);
+	span += offset;
+	dprintf("non-whitespace span is %zd", span);
+
+	if (line[span] == '\0') {
+		dprintf("returning %ld", (line + span) - start);
+		return (line + span) - start;
+	}
+	line[span] = '\0';
+
+	line += span + 1;
+	span = strspn(line, whitespace_and_eol_chars);
+	dprintf("whitespace span is %zd", span);
+	line += span;
+	tp->token = tp->pass;
+	tp->pass = line;
+
+	offset = 0;
+	do {
+		span = strcspn(line + offset, whitespace_and_eol_chars);
+		escspan = strescspn(line + offset);
+		if (escspan < span)
+			offset += escspan + 2;
+	} while(escspan < span);
+	span += offset;
+	dprintf("non-whitespace span is %zd", span);
+	if (line[span] != '\0')
+		line[span++] = '\0';
+
+	resolve_escapes(tp->token);
+	dprintf("Setting token pass %p to { %p, %p }", tp, tp->token, tp->pass);
+	dprintf("token:\"%s\"", tp->token);
+	dprintf("pass:\"%s\"", tp->pass);
+	dprintf("returning %ld", (line + span) - start);
+	return (line + span) - start;
 }
 
-/*
- *  p a s s w o r d _ h a r d c o d e 
- *
- *  A function to use the password passed in the -f(pwfile) argument
- *  of the command line.  
- *  After use once, null it out otherwise PKCS11 calls us forever.?
- *
- */
 static char *
 SECU_FilePasswd(PK11SlotInfo *slot, PRBool retry, void *arg)
 {
-    char* phrases, *phrase;
-    PRFileDesc *fd;
-    PRInt32 nb;
-    char *pwFile = arg;
-    int i;
-    const long maxPwdFileSize = 4096;
-    char* tokenName = NULL;
-    int tokenLen = 0;
+	cms_context *cms = (cms_context *)arg;
+	int fd;
+	char *file = NULL;
+	char *token_name = slot ? PK11_GetTokenName(slot) : NULL;
+	struct token_pass *phrases = NULL;
+	size_t nphrases = 0;
+	char *phrase = NULL;
+	char *start;
+	char *ret = NULL;
+	char *path;
 
-    if (!pwFile)
-	return 0;
+	ingress();
+	dprintf("token_name: %s", token_name);
+	path = cms->pwdata.data;
 
-    if (retry) {
-	return 0;  /* no good retrying - the files contents will be the same */
-    }
+	if (!path || retry)
+		goto err;
 
-    phrases = PORT_ZAlloc(maxPwdFileSize);
+	phrases = calloc(1, sizeof(struct token_pass));
+	if (!phrases)
+		goto err;
 
-    if (!phrases) {
-        return 0; /* out of memory */
-    }
- 
-    fd = PR_Open(pwFile, PR_RDONLY, 0);
-    if (!fd) {
-	fprintf(stderr, "No password file \"%s\" exists.\n", pwFile);
-        PORT_Free(phrases);
-	return NULL;
-    }
+	fd = open(path, O_RDONLY|O_CLOEXEC);
+	if (fd < 0) {
+		goto err_phrases;
+	} else {
+		size_t file_len = 0;
+		int rc;
+		rc = read_file(fd, &file, &file_len);
+		set_errno_guard();
+		close(fd);
 
-    nb = PR_Read(fd, phrases, maxPwdFileSize);
-  
-    PR_Close(fd);
+		if (rc < 0 || file_len < 1)
+			goto err_file;
+		file[file_len-1] = '\0';
+		dprintf("file_len:%zd", file_len);
+		dprintf("file:\"%s\"", file);
 
-    if (nb == 0) {
-        fprintf(stderr,"password file contains no data\n");
-        PORT_Free(phrases);
-        return NULL;
-    }
+		unbreak_line_continuations(file, file_len);
+	}
 
-    if (slot) {
-        tokenName = PK11_GetTokenName(slot);
-        if (tokenName) {
-            tokenLen = PORT_Strlen(tokenName);
-        }
-    }
-    i = 0;
-    do
-    {
-        int startphrase = i;
-        int phraseLen;
+	start = file;
+	while (start && start[0]) {
+		size_t span;
+		struct token_pass *new_phrases;
+		int rc;
+		char c;
 
-        /* handle the Windows EOL case */
-        while (phrases[i] != '\r' && phrases[i] != '\n' && i < nb) i++;
-        /* terminate passphrase */
-        phrases[i++] = '\0';
-        /* clean up any EOL before the start of the next passphrase */
-        while ( (i<nb) && (phrases[i] == '\r' || phrases[i] == '\n')) {
-            phrases[i++] = '\0';
-        }
-        /* now analyze the current passphrase */
-        phrase = &phrases[startphrase];
-        if (!tokenName)
-            break;
-        if (PORT_Strncmp(phrase, tokenName, tokenLen)) continue;
-        phraseLen = PORT_Strlen(phrase);
-        if (phraseLen < (tokenLen+1)) continue;
-        if (phrase[tokenLen] != ':') continue;
-        phrase = &phrase[tokenLen+1];
-        break;
+		new_phrases = reallocarray(phrases, nphrases + 1, sizeof(struct token_pass));
+		if (!new_phrases)
+			goto err_phrases;
+		phrases = new_phrases;
+		memset(&new_phrases[nphrases], 0, sizeof(struct token_pass));
 
-    } while (i<nb);
+		span = strspn(start, whitespace_and_eol_chars);
+		dprintf("whitespace span is %zd", span);
+		start += span;
+		span = strcspn(start, eol_chars);
+		dprintf("non-whitespace span is %zd", span);
 
-    phrase = PORT_Strdup((char*)phrase);
-    PORT_Free(phrases);
-    return phrase;
+		c = start[span];
+		start[span] = '\0';
+		dprintf("file:\"%s\"", file);
+		rc = parse_pwfile_line(start, &phrases[nphrases++]);
+		dprintf("parse_pwfile_line returned %d", rc);
+		if (rc < 0)
+			goto err_phrases;
+
+		if (c != '\0')
+			span++;
+		start += span;
+		dprintf("start is file[%ld] == '\\x%02hhx'", start - file, start[0]);
+	}
+
+	qsort(phrases, nphrases, sizeof(struct token_pass), token_pass_cmp);
+	cms->pwdata.source = PW_DATABASE;
+	xfree(cms->pwdata.data);
+	cms->pwdata.pwdb.phrases = phrases;
+	cms->pwdata.pwdb.nphrases = nphrases;
+
+	for (size_t i = 0; i < nphrases; i++) {
+		if (phrases[i].token == NULL || phrases[i].token[0] == '\0'
+		    || (token_name && !strcmp(token_name, phrases[i].token))) {
+			phrase = phrases[i].pass;
+			break;
+		}
+	}
+
+	if (phrase) {
+		ret = PORT_Strdup(phrase);
+		if (!ret)
+			errno = ENOMEM;
+	}
+
+err_file:
+	xfree(file);
+err_phrases:
+	xfree(phrases);
+err:
+	dprintf("ret:\"%s\"", ret ? ret : "(null)");
+	egress();
+	return ret;
 }
 
 char *
 get_password_passthrough(PK11SlotInfo *slot UNUSED,
 			 PRBool retry, void *arg)
 {
-	if (retry)
+	if (retry || !arg)
 		return NULL;
 
-	if (!arg)
-		return arg;
-
 	char *ret = strdup(arg);
-	if (!ret) {
-		fprintf(stderr, "Failed to allocate memory\n");
-		exit(1);
-	}
+	if (!ret)
+		err(1, "Could not allocate memory");
+
 	return ret;
 }
 
@@ -247,54 +367,126 @@ get_password_fail(PK11SlotInfo *slot UNUSED,
 	return NULL;
 }
 
+static bool
+can_prompt_again(secuPWData *pwdata)
+{
+	if (pwdata->orig_source == PW_PROMPT)
+		return true;
+
+	if (pwdata->source == PW_DEVICE)
+		return true;
+
+	return false;
+}
+
 char *
 SECU_GetModulePassword(PK11SlotInfo *slot, PRBool retry, void *arg)
 {
-    char prompt[255];
-    secuPWData *pwdata = (secuPWData *)arg;
-    secuPWData pwnull = { PW_NONE, 0 };
-    secuPWData pwxtrn = { PW_EXTERNAL, "external" };
-    char *pw;
-
-    if (pwdata == NULL)
-	pwdata = &pwnull;
-
-    if (PK11_ProtectedAuthenticationPath(slot)) {
-	pwdata = &pwxtrn;
-    }
-    if (retry && pwdata->source != PW_NONE) {
-	PR_fprintf(PR_STDERR, "Incorrect password/PIN entered.\n");
+	char *prompt = NULL;
+	cms_context *cms = (cms_context *)arg;
+	secuPWData *pwdata;
+	secuPWData pwxtrn = { .source = PW_DEVICE, .orig_source = PW_DEVICE, .data = NULL };
+	char *pw;
+	int rc;
+
+	ingress();
+
+	if (PK11_ProtectedAuthenticationPath(slot)) {
+		dprintf("prompting for PW_DEVICE data");
+		pwdata = &pwxtrn;
+	} else {
+		dprintf("using pwdata from cms");
+		pwdata = &cms->pwdata;
+	}
+
+	if (pwdata->source <= PW_SOURCE_INVALID ||
+	    pwdata->source >= PW_SOURCE_MAX ||
+	    pwdata->orig_source <= PW_SOURCE_INVALID ||
+	    pwdata->orig_source >= PW_SOURCE_MAX) {
+		dprintf("pwdata is invalid");
+		return NULL;
+	}
+
+	dprintf("pwdata:%p retry:%d", pwdata, retry);
+	dprintf("pwdata->source:%s (%d) orig:%s (%d)",
+		pw_source_names[pwdata->source], pwdata->source,
+		pw_source_names[pwdata->orig_source], pwdata->orig_source);
+	dprintf("pwdata->data:%p (\"%s\")", pwdata->data,
+		pwdata->data ? pwdata->data : "(null)");
+
+	if (retry) {
+		warnx("Incorrect password/PIN entered.");
+		if (!can_prompt_again(pwdata)) {
+			egress();
+			return NULL;
+		}
+	}
+
+	switch (pwdata->source) {
+	case PW_PROMPT:
+		rc = asprintf(&prompt, "Enter Password or Pin for \"%s\":",
+			      PK11_GetTokenName(slot));
+		if (rc < 0)
+			return NULL;
+		pw = SECU_GetPasswordString(NULL, prompt);
+		if (!pw)
+			return NULL;
+		free(prompt);
+
+		pwdata->source = PW_PLAINTEXT;
+		egress();
+		return pw;
+
+	case PW_DEVICE:
+		dprintf("pwdata->source:PW_DEVICE");
+		rc = asprintf(&prompt,
+			      "Press Enter, then enter PIN for \"%s\" on external device.\n",
+			      PK11_GetTokenName(slot));
+		if (rc < 0)
+			return NULL;
+		pw = SECU_GetPasswordString(NULL, prompt);
+		free(prompt);
+		return pw;
+
+	case PW_FROMFILEDB:
+	case PW_DATABASE:
+		dprintf("pwdata->source:%s", pw_source_names[pwdata->source]);
+		/* Instead of opening and closing the file every time, get the pw
+		 * once, then keep it in memory (duh).
+		 */
+		pw = SECU_FilePasswd(slot, retry, cms);
+		if (pw != NULL) {
+			pwdata->source = PW_PLAINTEXT;
+			pwdata->data = strdup(pw);
+		}
+		/* it's already been dup'ed */
+		egress();
+		return pw;
+
+	case PW_FROMENV:
+		dprintf("pwdata->source:PW_FROMENV");
+		if (!pwdata || !pwdata->data)
+			break;
+		pw = get_env(pwdata->data);
+		dprintf("env:%s pw:%s", pwdata->data, pw ? pw : "(null)");
+		pwdata->data = pw;
+		pwdata->source = PW_PLAINTEXT;
+		goto PW_PLAINTEXT;
+
+	PW_PLAINTEXT:
+	case PW_PLAINTEXT:
+		egress();
+		if (pwdata && pwdata->data)
+			return strdup(pwdata->data);
+		return NULL;
+
+	default:
+		break;
+	}
+
+	warnx("Password check failed: No password found.");
+	egress();
 	return NULL;
-    }
-
-    switch (pwdata->source) {
-    case PW_NONE:
-	sprintf(prompt, "Enter Password or Pin for \"%s\":",
-	                 PK11_GetTokenName(slot));
-	return SECU_GetPasswordString(NULL, prompt);
-    case PW_FROMFILE:
-	/* Instead of opening and closing the file every time, get the pw
-	 * once, then keep it in memory (duh).
-	 */
-	pw = SECU_FilePasswd(slot, retry, pwdata->data);
-	pwdata->source = PW_PLAINTEXT;
-	pwdata->data = PL_strdup(pw);
-	/* it's already been dup'ed */
-	return pw;
-    case PW_EXTERNAL:
-	sprintf(prompt,
-	        "Press Enter, then enter PIN for \"%s\" on external device.\n",
-		PK11_GetTokenName(slot));
-	(void) SECU_GetPasswordString(NULL, prompt);
-	/* Fall Through */
-    case PW_PLAINTEXT:
-	return PL_strdup(pwdata->data);
-    default:
-	break;
-    }
-
-    PR_fprintf(PR_STDERR, "Password check failed:  No password found.\n");
-    return NULL;
 }
 
 #if 0
@@ -307,28 +499,31 @@ readpw(PK11SlotInfo *slot UNUSED,
 {
 	struct termios sio, tio;
 	char line[LINE_MAX], *p;
+	char *ret;
 
+	ingress();
 	memset(line, '\0', sizeof (line));
 
 	if (tcgetattr(fileno(stdin), &sio) < 0) {
-		fprintf(stderr, "Could not read password from standard input.\n");
+		warnx("Could not read password from standard input.");
 		return NULL;
 	}
 	tio = sio;
 	tio.c_lflag &= ~ECHO;
 	if (tcsetattr(fileno(stdin), 0, &tio) < 0) {
-		fprintf(stderr, "Could not read password from standard input.\n");
+		warnx("Could not read password from standard input.");
 		return NULL;
 	}
 
 	fprintf(stdout, "Enter passphrase for private key: ");
-	if (fgets(line, sizeof(line), stdin) == NULL) {
-		fprintf(stdout, "\n");
-		tcsetattr(fileno(stdin), 0, &sio);
-		return NULL;
-	}
-	fprintf(stdout, "\n");
+	fflush(stdout);
+	ret = fgets(line, sizeof(line), stdin);
+	set_errno_guard();
 	tcsetattr(fileno(stdin), 0, &sio);
+	fprintf(stdout, "\n");
+	fflush(stdout);
+	if (ret == NULL)
+		return NULL;
 
 	p = line + strcspn(line, "\r\n");
 	if (p == NULL)
@@ -336,11 +531,14 @@ readpw(PK11SlotInfo *slot UNUSED,
 	if (p != NULL)
 		*p = '\0';
 
-	char *ret = strdup(line);
+	ret = strdup(line);
 	memset(line, '\0', sizeof (line));
 	if (!ret) {
-		fprintf(stderr, "Could not read passphrase.\n");
+		warnx("Could not read passphrase.");
 		return NULL;
 	}
+	egress();
 	return ret;
 }
+
+// vim:fenc=utf-8:tw=75:noet
diff --git a/src/pesign.c b/src/pesign.c
index 854120c15c5..e68a141b935 100644
--- a/src/pesign.c
+++ b/src/pesign.c
@@ -73,6 +73,10 @@ long verbosity(void)
 	return *verbose;
 }
 
+enum {
+	POPT_RET_PWDB = 0x40000001
+};
+
 int
 main(int argc, char *argv[])
 {
@@ -96,6 +100,10 @@ main(int argc, char *argv[])
 	char *certdir = "/etc/pki/pesign";
 	char *signum = NULL;
 
+	secuPWData pwdata;
+
+	memset(&pwdata, 0, sizeof(pwdata));
+
 	setenv("NSS_DEFAULT_DB_TYPE", "sql", 0);
 
 	rc = pesign_context_new(&ctxp);
@@ -273,6 +281,12 @@ main(int argc, char *argv[])
 		 .arg = &check_vendor_cert,
 		 .val = 0,
 		 .descrip = "do not hash the .vendor_cert section." },
+		{.longName = "pwfile",
+		 .shortName = '\0',
+		 .argInfo = POPT_ARG_STRING|POPT_ARGFLAG_DOC_HIDDEN,
+		 .arg = &pwdata.data,
+		 .descrip = "file to read passwords from.",
+		 .argDescrip = "<pwfile>" },
 		POPT_AUTOALIAS
 		POPT_AUTOHELP
 		POPT_TABLEEND
@@ -287,8 +301,32 @@ main(int argc, char *argv[])
 		exit(1);
 	}
 
-	while ((rc = poptGetNextOpt(optCon)) > 0)
-		;
+	while ((rc = poptGetNextOpt(optCon)) > 0) {
+		switch (rc) {
+		case POPT_RET_PWDB:
+			dprintf("POPT_RET_PWDB:\"%s\"", pwdata.data ? pwdata.data : "(null)");
+			if (pwdata.source != PW_SOURCE_INVALID)
+				errx(1, "only one password/pin method can be used at a time");
+			if (pwdata.data == NULL)
+				errx(1, "--pwfile requires a file name as an argument");
+			pwdata.source = PW_FROMFILEDB;
+			pwdata.data = strdup(pwdata.data);
+			if (!pwdata.data)
+				err(1, "could not allocate memory");
+			continue;
+		}
+	}
+
+	dprintf("pwdata.source:%d %schecking for PESIGN_TOKEN_PIN",
+		pwdata.source,
+		pwdata.source == PW_SOURCE_INVALID ? "" : "not ");
+	if (pwdata.source == PW_SOURCE_INVALID && secure_getenv("PESIGN_TOKEN_PIN")) {
+		pwdata.source = PW_FROMENV;
+		pwdata.data = strdup(secure_getenv("PESIGN_TOKEN_PIN"));
+		if (!pwdata.data)
+			err(1, "could not allocate memory");
+	}
+	pwdata.orig_source = pwdata.source;
 
 	if (rc < -1) {
 		fprintf(stderr, "pesign: Invalid argument: %s: %s\n",
@@ -411,6 +449,9 @@ main(int argc, char *argv[])
 		exit(!is_help);
 	}
 
+	if (pwdata.source != PW_DEVICE)
+		cms_set_pw_data(ctxp->cms_ctx, &pwdata);
+
 	ctxp->cms_ctx->omit_vendor_cert = !check_vendor_cert;
 
 	ctxp->cms_ctx->tokenname = tokenname ?
diff --git a/src/signer_info.c b/src/signer_info.c
index afa00e2c52e..6b73bce45d7 100644
--- a/src/signer_info.c
+++ b/src/signer_info.c
@@ -173,15 +173,14 @@ sign_blob(cms_context *cms, SECItem *sigitem, SECItem *sign_content)
 	if (!oid)
 		goto err;
 
-	PK11_SetPasswordFunc(cms->func ? cms->func : readpw);
-	SECKEYPrivateKey *privkey = PK11_FindKeyByAnyCert(cms->cert,
-				cms->pwdata ? cms->pwdata : NULL);
+	PK11_SetPasswordFunc(cms->func ? cms->func : SECU_GetModulePassword);
+	SECKEYPrivateKey *privkey = PK11_FindKeyByAnyCert(cms->cert, cms);
 	if (!privkey) {
 		cms->log(cms, LOG_ERR, "could not get private key: %s",
 			PORT_ErrorToString(PORT_GetError()));
 		goto err;
 	}
-	
+
 	SECItem *signature, tmp;
 	memset (&tmp, '\0', sizeof (tmp));
 
@@ -446,3 +445,5 @@ generate_authvar_signer_info(cms_context *cms, SpcSignerInfo *sip)
 err:
 	return -1;
 }
+
+// vim:fenc=utf-8:tw=75:noet
diff --git a/src/cms_common.h b/src/cms_common.h
index b0dc12fc3ab..34ab6551ddd 100644
--- a/src/cms_common.h
+++ b/src/cms_common.h
@@ -25,11 +25,15 @@
 #include <errno.h>
 #include <signal.h>
 #include <stdarg.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
 #include <syslog.h>
 #include <time.h>
 #include <unistd.h>
 
 #include "util.h"
+#include "password.h"
 
 #define save_port_err() \
 	for (error_t saved_errno_0_ = 0, saved_errno_1_ = PORT_GetError(); saved_errno_0_ < 1; saved_errno_0_++, PORT_SetError(saved_errno_1_))
@@ -56,6 +60,44 @@ struct digest {
 	SECItem *pe_digest;
 };
 
+struct token_pass {
+	char *token;
+	char *pass;
+};
+
+struct pw_database {
+	struct token_pass *phrases;
+	size_t nphrases;
+};
+
+typedef enum {
+	// used only for bounds checking
+	PW_SOURCE_INVALID = 0,
+	// prompt the user (pwdata->data is NULL)
+	PW_PROMPT = 1,
+	// prompt the user to use a device (pwdata->data is NULL)
+	PW_DEVICE = 2,
+	// pwdata->data is plain text
+	PW_PLAINTEXT = 3,
+	// pwdata->data is a filename for a database
+	PW_FROMFILEDB = 4,
+	// pwdata->data is the database data
+	PW_DATABASE = 5,
+	// pwdata->data is the name of an environment variable
+	PW_FROMENV = 6,
+
+	// used only for bounds checking
+	PW_SOURCE_MAX
+} pw_source_t;
+
+typedef struct {
+	pw_source_t source;
+	pw_source_t orig_source;
+
+	struct pw_database pwdb;
+	char *data;
+} secuPWData;
+
 struct cms_context;
 
 typedef int (*cms_common_logger)(struct cms_context *, int priority,
@@ -68,8 +110,9 @@ typedef struct cms_context {
 	char *tokenname;
 	char *certname;
 	CERTCertificate *cert;
+	PK11SlotListElement *psle;
 	PK11PasswordFunc func;
-	void *pwdata;
+	secuPWData pwdata;
 
 	struct digest *digests;
 	int selected_digest;
@@ -156,7 +199,7 @@ extern SECOidTag digest_get_encryption_oid(cms_context *cms);
 extern SECOidTag digest_get_signature_oid(cms_context *cms);
 extern int digest_get_digest_size(cms_context *cms);
 extern void cms_set_pw_callback(cms_context *cms, PK11PasswordFunc func);
-extern void cms_set_pw_data(cms_context *cms, void *pwdata);
+extern void cms_set_pw_data(cms_context *cms, secuPWData *pwdata);
 
 extern int set_digest_parameters(cms_context *ctx, char *name);
 
@@ -164,15 +207,5 @@ extern int generate_digest_begin(cms_context *cms);
 extern void generate_digest_step(cms_context *cms, void *data, size_t len);
 extern int generate_digest_finish(cms_context *cms);
 
-typedef struct {
-	enum {
-		PW_NONE = 0,
-		PW_FROMFILE = 1,
-		PW_PLAINTEXT = 2,
-		PW_EXTERNAL = 3
-	} source;
-	char *data;
-} secuPWData;
-
 #endif /* CMS_COMMON_H */
 // vim:fenc=utf-8:tw=75:noet
-- 
2.29.2

