From 2cd818c0ef885276cc66ff39bcbe01a90d385db8 Mon Sep 17 00:00:00 2001
From: Peter Jones <pjones@redhat.com>
Date: Mon, 22 Jun 2020 10:35:22 -0400
Subject: [PATCH 08/42] Add some text parsing helpers

Signed-off-by: Peter Jones <pjones@redhat.com>
---
 src/text.c   | 259 +++++++++++++++++++++++++++++++++++++++++++++++++++
 src/pesign.h |   1 +
 src/text.h   |  53 +++++++++++
 src/Makefile |   2 +-
 4 files changed, 314 insertions(+), 1 deletion(-)
 create mode 100644 src/text.c
 create mode 100644 src/text.h

diff --git a/src/text.c b/src/text.c
new file mode 100644
index 00000000000..e463e8d05eb
--- /dev/null
+++ b/src/text.c
@@ -0,0 +1,259 @@
+// SPDX-License-Identifier: GPLv2
+/*
+ * text.c - helpers for text strings
+ * Copyright Peter Jones <pjones@redhat.com>
+ */
+#include "compiler.h"
+#include "text.h"
+
+#include <stdbool.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+
+const char * const eol_chars = "\f\r\v\n";
+// static const char * const whitespace_chars = "\t ";
+const char * const whitespace_and_eol_chars = "\t \f\r\v\n";
+
+// static const char * const binary_digits = "01";
+static const char * const octal_digits = "01234567";
+// static const char * const decimal_digits = "0123456789";
+static const char * const hex_digits = "0123456789abcdefABCDEF";
+
+static const char * const cnt_nl = "\\\n";
+static const char * const cnt_lfnl = "\\\r\n";
+static const char * const cnt_lf = "\\\r";
+static const char * const cnt_ff = "\\\f";
+static const char * const cnt_vt = "\\\v";
+
+static const char * const line_continuation_strs[] = {
+	cnt_nl,
+	cnt_lfnl,
+	cnt_lf,
+	cnt_ff,
+	cnt_vt,
+	NULL
+};
+
+/*
+ * unbreak_line_coninutations: remove all line continuations
+ * @buf:	the buffer to operate on
+ * @bufsz:	the size of the buffer
+ */
+void
+unbreak_line_continuations(char *buf, size_t bufsz)
+{
+	char *to = buf;
+	bool found = true;
+
+	while (found) {
+		found = false;
+
+		for (unsigned int i = 0; line_continuation_strs[i]; i++) {
+			size_t cntsz = strlen(line_continuation_strs[i]);
+			char *needle = strstr(to, line_continuation_strs[i]);
+			char *from;
+			size_t sz;
+
+			if (!needle)
+				continue;
+
+			found = true;
+			from = needle + cntsz;
+			sz = bufsz - (from - buf);
+
+			to = needle;
+			memmove(to, from, sz);
+		}
+	}
+}
+
+/*
+ * stresccspn:	calculate the number of bytes which do not contain escape
+ *		sequences.
+ * @buf:	the buffer to search
+ *
+ * Returns the size of the initial segment of buf which does not contain
+ * any escape sequences.  If no escape sequence is found, buf[return] will
+ * point to the NUL terminator.
+ */
+size_t stresccspn(const char * const buf)
+{
+	size_t span = strcspn(buf, "\\");
+
+	return span;
+}
+
+/*
+ * escape_func: parse the value for one single escape character
+ * @delimiter:	the delimiter as to which kind of escape sequence this is
+ *		(i.e. 'x' for \x1abc)
+ * @buf:	the buffer being parsed
+ * @val:	the parsed value is placed in val
+ * @valsz:	how many bytes of val are meaningful
+ *
+ * Returns the number of bytes of buf to advance to skip the escape
+ * sequence, including the delimiter character but not the initial escape
+ * character.  If the initial segment of buf is not an escape sequence,
+ * *valsz and the return value will both be 0.
+ */
+typedef size_t (*escape_func)(uint32_t delimiter, const char * const buf,
+			      char val[9], size_t *valsz);
+
+static size_t
+simple_escape_sequence(uint32_t delimiter, const char * const buf UNUSED,
+		       char val[9], size_t *valsz)
+{
+	val[0] = delimiter & 0xffu;
+	*valsz = 1;
+
+	return 1;
+}
+
+static size_t
+digits_escape_sequence(uint32_t delimiter, const char * const buf,
+		       char val[2], size_t *valsz)
+{
+	size_t span;
+	unsigned long long ul;
+	char tmpbuf[4] = { 0, };
+	int base;
+
+	if (delimiter == 'x') {
+		span = strspn(buf, hex_digits);
+		base = 16;
+		if (span > 2)
+			span = 2;
+		strncpy(tmpbuf, buf, span);
+	} else {
+		span = strspn(buf, octal_digits);
+		base = 8;
+		if (span > 2)
+			span = 2;
+		tmpbuf[0] = delimiter & 0xffu;
+		strncpy(&tmpbuf[1], buf, span);
+		span += 1;
+	}
+	if (span == 0) {
+		val[0] = delimiter & 0xffu;
+		*valsz = 1;
+		return 1;
+	}
+
+	tmpbuf[span+1] = '\0';
+	ul = strtoul(tmpbuf, NULL, base);
+
+	val[0] = ul & 0xffu;
+	*valsz = 1;
+
+	return span;
+}
+
+struct escape_handler {
+	const char * const escapes;
+	escape_func func;
+};
+static struct escape_handler escape_handlers[] = {
+	{.escapes = " \"\'\?\a\b\f\n\r\t\v\\",
+	 .func = simple_escape_sequence },
+	{.escapes = "x01234567",
+	 .func = digits_escape_sequence },
+	{.escapes = 0,
+	 .func = NULL }
+};
+
+/*
+ * parse_escape: parses one escape string
+ * @buf:	the buffer being parsed
+ * @val:	the parsed value is placed in val
+ * @valsz:	how many bytes of val are meaningful
+ *
+ * Returns the number of bytes of buf to advance to skip the escape
+ * sequence.  If the initial segment of buf is not an escape sequence,
+ * *valsz and the return value will both be 0.
+ */
+static size_t
+parse_escape(const char * const buf, char val[9], size_t *valsz)
+{
+	struct escape_handler *eh = NULL;
+
+	if (buf[0] != '\\')
+		return 0;
+
+	for(size_t i = 0; escape_handlers[i].escapes != 0; i++) {
+		char *match;
+		eh = &escape_handlers[i];
+
+		match = strchrnul(eh->escapes, buf[1]);
+		if (match[0] != buf[1])
+			continue;
+	}
+	if (eh && eh->func)
+		return eh->func(buf[1], &buf[2], val, valsz);
+	return 0;
+}
+
+/*
+ * strescspn:	calculate the size of an escape sequence.
+ * @buf:	a NUL-terminated utf-8 buffer.
+ *
+ * returns the number of bytes which are part of a single escape sequence.
+ * If no escape sequnce can be parsed, returns 0.
+ */
+size_t strescspn(const char * const buf)
+{
+	size_t advance = 0, valsz = 0;
+	char val[9] = { 0, };
+
+	if (!buf[0] || buf[0] != '\\')
+		return 0;
+
+	advance = parse_escape(&buf[1], val, &valsz);
+	if (advance == 0) {
+		/*
+		 * If we come to illegal escape values like "\\xzz" then
+		 * we just use the delimiter character (in this case 'x'),
+		 * so the span here is 2.
+		 */
+		return 2;
+	}
+	return valsz + 1;
+}
+
+/*
+ * resolve_escapes: parse all instances of escape sequences in buf
+ * @buf:	the buffer to operate on
+ *
+ * Returns the size of buf once escape sequnces have been replaced.
+ */
+size_t
+resolve_escapes(char *buf)
+{
+	size_t to = 0;
+	for (size_t from = 0; buf[from]; from++) {
+		size_t advance, valsz = 0;
+		char val[9];
+		if (buf[from] != '\\') {
+			buf[to++] = buf[from];
+			continue;
+		}
+
+		advance = parse_escape(&buf[from], val, &valsz);
+		if (advance == 0) {
+			/*
+			 * If we come to illegal escape values like "\\xzz"
+			 * then just move the '\\' out of the way...
+			 */
+			buf[to++] = buf[++from];
+			continue;
+		}
+
+		for (size_t j = 0; j < valsz; j++)
+			buf[to+j] = val[j];
+		to += advance + 1;
+	}
+	buf[to++] = '\0';
+	return to;
+}
+
+// vim:fenc=utf-8:tw=75:noet
diff --git a/src/pesign.h b/src/pesign.h
index 9f80a9ad108..1b404223d31 100644
--- a/src/pesign.h
+++ b/src/pesign.h
@@ -25,6 +25,7 @@
 #include <libdpe/pe.h>
 
 #include "util.h"
+#include "text.h"
 #include "cms_common.h"
 #include "pesign_context.h"
 
diff --git a/src/text.h b/src/text.h
new file mode 100644
index 00000000000..e5722c7aee1
--- /dev/null
+++ b/src/text.h
@@ -0,0 +1,53 @@
+// SPDX-License-Identifier: GPLv2
+/*
+ * text.c - helpers for text strings
+ * Copyright Peter Jones <pjones@redhat.com>
+ */
+#ifndef TEXT_H_
+#define TEXT_H_
+
+#include <unistd.h>
+
+/*
+ * Characters that can be considered whitespace or end-of-line markers.
+ */
+extern const char * const eol_chars;
+extern const char * const whitespace_and_eol_chars;
+
+/*
+ * unbreak_line_coninutations: remove all line continuations
+ * @buf:	the buffer to operate on
+ * @bufsz:	the size of the buffer
+ */
+extern void unbreak_line_continuations(char *buf, size_t bufsz);
+
+/*
+ * strescspn:	calculate the size of an escape sequence.
+ * @buf:	a NUL-terminated utf-8 buffer.
+ *
+ * returns the number of bytes which are part of a single escape sequence.
+ * If no escape sequnce can be parsed, returns 0.
+ */
+extern size_t strescspn(const char * const buf);
+
+/*
+ * stresccspn:	calculate the number of bytes which do not contain escape
+ *		sequences.
+ * @buf:	the buffer to search
+ *
+ * Returns the size of the initial segment of buf which does not contain
+ * any escape sequences.  If no escape sequence is found, buf[return] will
+ * point to the NUL terminator.
+ */
+extern size_t stresccspn(const char * const buf);
+
+/*
+ * resolve_escapes: parse all instances of escape sequences in buf
+ * @buf:	the buffer to operate on
+ *
+ * Returns the size of buf once escape sequnces have been replaced.
+ */
+extern size_t resolve_escapes(char *buf);
+
+#endif /* !TEXT_H_ */
+// vim:fenc=utf-8:tw=75:noet
diff --git a/src/Makefile b/src/Makefile
index 74327ba13f3..dfdc7c5e4c5 100644
--- a/src/Makefile
+++ b/src/Makefile
@@ -12,7 +12,7 @@ TARGETS=$(BINTARGETS) $(SVCTARGETS)
 all : deps $(TARGETS)
 
 COMMON_SOURCES = cms_common.c content_info.c oid.c password.c \
-	signed_data.c signer_info.c ucs2.c
+	signed_data.c signer_info.c text.c ucs2.c
 COMMON_PE_SOURCES = wincert.c cms_pe_common.c
 AUTHVAR_SOURCES = authvar.c authvar_context.c
 CLIENT_SOURCES = pesign_context.c actions.c client.c
-- 
2.29.2

